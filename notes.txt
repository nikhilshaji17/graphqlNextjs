GraphQL allows the client to request only the exact amount of data they need. 
- This allows less data to be transferred over the network.
- Only relevant data is transferred.
- It is type safe, only the correctly requested data is transferred.

For REST API's:
- In order to send a PUT request, you would have routes like user/userId 
- In order to send a GET request, you would have routes like user/userInfo
- This would lead to a lot of routes to maintain

For GraphQL:
- We would have a single endpoint, typically /graphql
- The request type would be a POST request, and depending on the query, we get 
  relevant info back.
- i.e, the query changes, but not the URL, therefore easier to maintain/understand.

SDL = Schema definition language

Scalar Types: String, Int, Boolean, Float, ID.
Object Types: Define an object that you want to fetch from your data source, and what fields 
  it has:
  eg: type User {
    id: ID!,
    name: String!,
    email: String!,
    posts: [Post]
  }
(The exclamation means it has to be a Non-Null return)
It is composed of other scalar and object types.


Example:
type Person {
  name: String!
}

type Query {
  me: Person!
}

The "me" field on Query has to return a "Person".
The "name" field on Person has to return a "String".

const server = new ApolloServer({
  schema: addMocksToSchema({
    schema: makeExecutableSchema({ typeDefs }),
  }),
  plugins,
})

The above lines of code in route.ts adds mock data to your schema.
This allows us to immediately start using our graphql api, without having to configure a 
  db.

__typename: Tells you what object you are resolving to.

... on Person {  // triple dot is called inline fragment
      backgroundStory
  }

Type Modifiers:
! => The field cannot be NULL.
[] => The field is a list type.

One flaw with GraphQL is because of its cyclical nature, you can have an object which has a 1-1 relationship with
  another object. Due to this nature, attackers could DDoS your GraphQL API with an infinitely nested request.

Directives:
You can place a directive on a field, a type or the actual value.

Directives alter the way the server interprets the schema.
  We can use them for documentation (example: @deprecated()), authentication (example: @auth())
  and so on.

You can tie into many stages of a hook in graphQL, like the start phase, after fetching data, etc.

Enum types:
  Example: 
    enum Role {
      ADMIN
      USER
      ROLE
    }
  This makes it such that a field would have a string value, but it has to be one of the values
  in the enum.

Operations in GraphQL:
Queries:
  These are like GET requests.
  You need a minimum of 1 query. Else, the program does not work.

You can pass an argument to a query.
query Query($input: SearchInput!) {

}
$input = argument name
SearchInput = argument type

Mutation:
  These are like POST, PUT, DELETE
  You are trying to modify something from the server.

The syntax of a mutation and query are pretty much the same, but their behaviour on 
  the backend is different. Mutation for edits, query for fetching

Subscriptions:
Used for real-time events.

END OF OPERATIONS

Resolvers:
Resolvers provide the instructions for turning a GraphQL operation 
  (query, mutation, or subscription) into data. 
They define how to fetch or modify the data exactly as the client requests.

Queries describes the contract, and resolvers define how to get the values of that contract.

So when we run a query, the resolver attached to that query is what describes the structure of
  the data we get back.

Structure of a resolver:
  const resolvers = {
  Query: {
    user: (parent, args, context, info) => {
      return context.dataSources.userAPI.getUserById(args.id);
    }
  }
}
So on the Query type, when someone asks for the user field, the function above is the one that runs.

The 4 arguments of the resolver function:
  1. parent => Most likely null, if we are running a top level query.
  2. args => similar to props in react, takes all the arguments of the query.
  3. context => initialized at the beginning of the server, it takes the state of our system (or something like that)
  4. info => information of the actual query itself. Mainly used for analytics and metadata details.

  5. return value => You can choose to return anything you want, a String, and array of promises and so on.

If your schema is this:
const schema = `#graphql

  type Query {
    me: String!
    id: ID!
  }
`

export default schema

Then your resolver will be something like:
const resolvers = {
  Query: {
    me: () => {
      return "hello there";
    },

    id: () => {
      return (123)
    }
  }
}

export default resolvers


Example 2:
const schema = `#graphql

  type Person {
    name: String
    id: ID
  }

  type Query {
    me: String!
    people: [Person!]!
  }
`

export default schema

const resolvers = {

  Person: {
    name: (person) => {
      return person.name.toUpperCase()
    }
  },
  Query: {
    me: () => {
      return "hello there";
    },
    people: () => {
      return [{name: "Sam", id: 123}]
    }
  }
}

The people function will run, and get an array back, then the Person.name function runs,
  modifying the name to be uppercase.

Resolving Enums:
Typically, enum values do not require special resolver functions; 
  they are validated by the GraphQL server against the schema and returned directly.

However, we can map enums to different values in case:
  1. We want to output different values in the UI

Example: 
  enum COLORS {
    BLUE
    PURPLE
    BROWN
  }
  All colors can be mapped to their HEX value in the resolver.

Resolving Unions:
We need to add a __resolveType to identify what union to return.

SearchType: {
    __resolveType: (obj) => {
      if (obj.species) {
        return 'Animal';
      }
      return 'Person';
    },
}

Resolving Interfaces:
Similar to resolving unions, we need to add a __resolveType here as well.

NOTE: If you are going to make a resolver for an object type, it will always 
  have a parent.

Setting up a GraphQL server:
To set up a GQL server, you need a schema + a resolver

ORM = Object-relational mapping (The code you use to interact with your db.)

