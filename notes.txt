GraphQL allows the client to request only the exact amount of data they need. 
- This allows less data to be transferred over the network.
- Only relevant data is transferred.
- It is type safe, only the correctly requested data is transferred.

For REST API's:
- In order to send a PUT request, you would have routes like user/userId 
- In order to send a GET request, you would have routes like user/userInfo
- This would lead to a lot of routes to maintain

For GraphQL:
- We would have a single endpoint, typically /graphql
- The request type would be a POST request, and depending on the query, we get 
  relevant info back.
- i.e, the query changes, but not the URL, therefore easier to maintain/understand.

SDL = Schema definition language

Scalar Types: String, Int, Boolean, Float, ID.
Object Types: Define an object that you want to fetch from your data source, and what fields 
  it has:
  eg: type User {
    id: ID!,
    name: String!,
    email: String!,
    posts: [Post]
  }
(The exclamation means it has to be a Non-Null return)
It is composed of other scalar and object types.


Example:
type Person {
  name: String!
}

type Query {
  me: Person!
}

The "me" field on Query has to return a "Person".
The "name" field on Person has to return a "String".

const server = new ApolloServer({
  schema: addMocksToSchema({
    schema: makeExecutableSchema({ typeDefs }),
  }),
  plugins,
})

The above lines of code in route.ts adds mock data to your schema.
This allows us to immediately start using our graphql api, without having to configure a 
  db.

__typename: Tells you what object you are resolving to.

... on Person {  // triple dot is called inline fragment
      backgroundStory
  }

Type Modifiers:
! => The field cannot be NULL.
[] => The field is a list type.

One flaw with GraphQL is because of its cyclical nature, you can have an object which has a 1-1 relationship with
  another object. Due to this nature, attackers could DDoS your GraphQL API with an infinitely nested request.

Directives:
You can place a directive on a field, a type or the actual value.

Directives alter the way the server interprets the schema.
  We can use them for documentation (example: @deprecated()), authentication (example: @auth())
  and so on.

You can tie into many stages of a hook in graphQL, like the start phase, after fetching data, etc.

Enum types:
  Example: 
    enum Role {
      ADMIN
      USER
      ROLE
    }
  This makes it such that a field would have a string value, but it has to be one of the values 
  in the enum.

Operations in GraphQL:
